use crate::instruction_types::{ISABase, ISAExtension, Instruction, Operand};
use proc_macro2::{Span, TokenStream};
use quote::quote;
use std::collections::{HashMap, HashSet};
use syn::Ident;

/// 指令变体，用于分析指令在不同 ISA 基础之间的共享性
#[derive(Debug, Clone)]
struct InstructionVariant {
    instruction: Instruction,
    isa_bases: Vec<ISABase>,
    is_shared: bool,
}

/// RISC-V 指令代码生成器
pub struct CodeGenerator {
    rvc_instructions: Vec<Instruction>,
    standard_instructions: Vec<Instruction>,
}

impl CodeGenerator {
    pub fn new(
        rvc_instructions: Vec<Instruction>,
        standard_instructions: Vec<Instruction>,
    ) -> Self {
        Self {
            rvc_instructions,
            standard_instructions,
        }
    }

    /// 生成完整的指令枚举代码
    pub fn generate_instruction_enum(&self) -> TokenStream {
        let rvc_analysis = self.analyze_instruction_sharing_for_type(&self.rvc_instructions);
        let standard_analysis =
            self.analyze_instruction_sharing_for_type(&self.standard_instructions);

        let mut restricted_register_defs = TokenStream::new();
        let mut restricted_immediate_defs = TokenStream::new();
        let mut processed_register_combinations = std::collections::HashSet::new();
        let mut processed_immediate_combinations = std::collections::HashSet::new();

        // 收集所有需要的受限类型定义
        for analysis in [&rvc_analysis, &standard_analysis] {
            for variants in analysis.values() {
                for variant in variants {
                    for operand in &variant.instruction.operands {
                        if let Some(restriction) = &operand.restrictions {
                            // 处理寄存器类型
                            if self.is_register_operand(&operand.name)
                                && !restriction.forbidden_values.is_empty()
                            {
                                let base_type = self.get_register_base_type(&operand.name);
                                let type_signature =
                                    (base_type, restriction.forbidden_values.clone());
                                if processed_register_combinations.insert(type_signature.clone()) {
                                    let type_def = self.generate_restricted_register_type_def(
                                        base_type,
                                        &restriction.forbidden_values,
                                    );
                                    restricted_register_defs.extend(type_def);
                                }
                            }

                            // 处理立即数类型
                            if self.is_immediate_operand(&operand.name) {
                                let isa_base = &variant.isa_bases[0]; // 使用第一个ISA基础
                                let bit_length = operand.bit_lengths.get(isa_base).unwrap_or(&32);
                                let type_signature = self.create_immediate_type_signature(
                                    &operand.name,
                                    *bit_length,
                                    restriction,
                                );

                                if processed_immediate_combinations.insert(type_signature.clone()) {
                                    let type_def = self.generate_restricted_immediate_type_def(
                                        &operand.name,
                                        *bit_length,
                                        restriction,
                                    );
                                    restricted_immediate_defs.extend(type_def);
                                }
                            }
                        }
                    }
                }
            }
        }

        let imports = self.generate_imports();
        let rvc_enums = self.generate_instruction_type_enums(&rvc_analysis, "RVC");
        let standard_enums = self.generate_instruction_type_enums(&standard_analysis, "Standard");
        let main_enum = self.generate_top_level_enum(&rvc_analysis, &standard_analysis);

        quote! {
            // This file is auto-generated by the RISC-V instruction code generator.
            // Author: canxin121 <q1969730106@gmail.com>
            // Do not edit this file manually.
            #imports

            #restricted_register_defs

            #restricted_immediate_defs

            #rvc_enums

            #standard_enums

            #main_enum
        }
    }

    /// 分析指令在 ISA 基础之间的共享性
    fn analyze_instruction_sharing_for_type(
        &self,
        instructions: &[Instruction],
    ) -> HashMap<ISAExtension, Vec<InstructionVariant>> {
        let mut analysis: HashMap<ISAExtension, Vec<InstructionVariant>> = HashMap::new();
        let mut by_extension: HashMap<ISAExtension, Vec<&Instruction>> = HashMap::new();

        for inst in instructions {
            by_extension.entry(inst.extension).or_default().push(inst);
        }

        for (extension, instructions) in by_extension {
            let mut variants = Vec::new();
            let mut processed_names = HashSet::new();

            for &inst in &instructions {
                if processed_names.contains(&inst.name) {
                    continue;
                }
                processed_names.insert(&inst.name);

                let same_name_instructions: Vec<&Instruction> = instructions
                    .iter()
                    .filter(|&&i| i.name == inst.name)
                    .copied()
                    .collect();

                if same_name_instructions.len() == 1 {
                    variants.push(InstructionVariant {
                        instruction: inst.clone(),
                        isa_bases: inst.isa_bases.clone(),
                        is_shared: inst.isa_bases.len() > 1,
                    });
                } else {
                    let is_identical = self.are_instructions_identical(&same_name_instructions);
                    if is_identical {
                        let mut merged_isa_bases = Vec::new();
                        for inst in &same_name_instructions {
                            for &isa_base in &inst.isa_bases {
                                if !merged_isa_bases.contains(&isa_base) {
                                    merged_isa_bases.push(isa_base);
                                }
                            }
                        }
                        let mut merged_inst = inst.clone();
                        merged_inst.isa_bases = merged_isa_bases.clone();
                        variants.push(InstructionVariant {
                            instruction: merged_inst,
                            isa_bases: merged_isa_bases.clone(),
                            is_shared: merged_isa_bases.len() > 1,
                        });
                    } else {
                        for &different_inst in &same_name_instructions {
                            variants.push(InstructionVariant {
                                instruction: different_inst.clone(),
                                isa_bases: different_inst.isa_bases.clone(),
                                is_shared: false,
                            });
                        }
                    }
                }
            }
            analysis.insert(extension, variants);
        }
        analysis
    }

    fn are_instructions_identical(&self, instructions: &[&Instruction]) -> bool {
        if instructions.len() <= 1 {
            return true;
        }
        let first = instructions[0];
        for &inst in &instructions[1..] {
            if first.operands.len() != inst.operands.len() {
                return false;
            }
            for (op1, op2) in first.operands.iter().zip(inst.operands.iter()) {
                if op1.name != op2.name {
                    return false;
                }
                for &isa_base in &[ISABase::RV32, ISABase::RV64] {
                    if op1.bit_lengths.get(&isa_base) != op2.bit_lengths.get(&isa_base) {
                        return false;
                    }
                }
            }
            if first.assembly_syntax != inst.assembly_syntax {
                return false;
            }
        }
        true
    }

    /// 生成指令类型的所有枚举
    fn generate_instruction_type_enums(
        &self,
        analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        type_prefix: &str,
    ) -> TokenStream {
        let mut all_enums = TokenStream::new();

        let shared_enums = self.generate_shared_instructions_enum_for_type(analysis, type_prefix);
        all_enums.extend(shared_enums);

        let specific_enums =
            self.generate_isa_specific_instructions_enum_for_type(analysis, type_prefix);
        all_enums.extend(specific_enums);

        let main_enums = self.generate_type_main_enum(analysis, type_prefix);
        all_enums.extend(main_enums);

        all_enums
    }

    /// 生成共享指令枚举
    fn generate_shared_instructions_enum_for_type(
        &self,
        analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        type_prefix: &str,
    ) -> TokenStream {
        let mut all_enums = TokenStream::new();
        for (extension, variants) in analysis {
            let shared_variants: Vec<_> = variants.iter().filter(|v| v.is_shared).collect();
            if shared_variants.is_empty() {
                continue;
            }

            let enum_name = Ident::new(
                &format!("{}{}SharedInstructions", type_prefix, extension),
                Span::call_site(),
            );
            let doc_comment = format!(
                "{} shared instructions for {} extension",
                type_prefix, extension
            );

            let variant_tokens = self.build_variants(&shared_variants, None);

            all_enums.extend(quote! {
                #[doc = #doc_comment]
                #[derive(Debug, Clone, PartialEq, DeriveInstructionDisplay, DeriveRandom)]
                #[rustfmt::skip]
                pub enum #enum_name {
                    #(#variant_tokens),*
                }
            });
        }
        all_enums
    }

    /// 生成 ISA 特定指令枚举
    fn generate_isa_specific_instructions_enum_for_type(
        &self,
        analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        type_prefix: &str,
    ) -> TokenStream {
        let mut all_enums = TokenStream::new();
        for isa_base in &[ISABase::RV32, ISABase::RV64] {
            for (extension, variants) in analysis {
                let isa_specific_variants: Vec<_> = variants
                    .iter()
                    .filter(|v| !v.is_shared && v.isa_bases.contains(isa_base))
                    .collect();

                if isa_specific_variants.is_empty() {
                    continue;
                }

                let enum_name = Ident::new(
                    &format!(
                        "{}{}{}SpecificInstructions",
                        type_prefix, isa_base, extension
                    ),
                    Span::call_site(),
                );
                let doc_comment = format!(
                    "{} {} specific instructions for {} extension",
                    type_prefix, isa_base, extension
                );

                let variant_tokens = self.build_variants(&isa_specific_variants, Some(isa_base));

                all_enums.extend(quote! {
                    #[doc = #doc_comment]
                    #[derive(Debug, Clone, PartialEq, DeriveInstructionDisplay, DeriveRandom)]
                    #[rustfmt::skip]
                    pub enum #enum_name {
                        #(#variant_tokens),*
                    }
                });
            }
        }
        all_enums
    }

    /// 生成指令类型的主枚举
    fn generate_type_main_enum(
        &self,
        analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        type_prefix: &str,
    ) -> TokenStream {
        let mut main_enums = TokenStream::new();

        // 生成共享指令枚举
        let shared_variants = analysis
            .iter()
            .filter_map(|(ext, vars)| {
                if vars.iter().any(|v| v.is_shared) {
                    let ext_ident = Ident::new(&ext.to_string(), Span::call_site());
                    let enum_name = Ident::new(
                        &format!("{}{}SharedInstructions", type_prefix, ext),
                        Span::call_site(),
                    );
                    Some(quote! { #ext_ident(#enum_name) })
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        if !shared_variants.is_empty() {
            let shared_enum_name = Ident::new(
                &format!("{}SharedInstruction", type_prefix),
                Span::call_site(),
            );
            let shared_doc = format!(
                "{} instructions shared across all ISA bases, grouped by extension.",
                type_prefix
            );
            main_enums.extend(quote! {
                #[doc = #shared_doc]
                #[derive(Debug, Clone, PartialEq, DeriveInstructionDisplay, DeriveRandom)]
                pub enum #shared_enum_name {
                    #(#shared_variants),*
                }
            });
        }

        // 生成 ISA 特定枚举
        for isa_base in &[ISABase::RV32, ISABase::RV64] {
            let isa_base_str = isa_base.to_string();
            let specific_enum_name = Ident::new(
                &format!("{}{}SpecificInstruction", type_prefix, isa_base),
                Span::call_site(),
            );
            let doc_comment = format!(
                "{} {} specific instructions, grouped by extension.",
                type_prefix, isa_base_str
            );

            let extension_variants = analysis
                .iter()
                .filter_map(|(ext, vars)| {
                    if vars
                        .iter()
                        .any(|v| !v.is_shared && v.isa_bases.contains(isa_base))
                    {
                        let ext_ident = Ident::new(&ext.to_string(), Span::call_site());
                        let enum_name = Ident::new(
                            &format!("{}{}{}SpecificInstructions", type_prefix, isa_base, ext),
                            Span::call_site(),
                        );
                        Some(quote! { #ext_ident(#enum_name) })
                    } else {
                        None
                    }
                })
                .collect::<Vec<_>>();

            if !extension_variants.is_empty() {
                main_enums.extend(quote! {
                    #[doc = #doc_comment]
                    #[derive(Debug, Clone, PartialEq, DeriveInstructionDisplay, DeriveRandom)]
                    pub enum #specific_enum_name {
                        #(#extension_variants),*
                    }
                });
            }
        }

        // 生成指令类型特定枚举
        let specific_variants = [ISABase::RV32, ISABase::RV64]
            .iter()
            .filter_map(|isa_base| {
                let has_specific = analysis.values().any(|vars| {
                    vars.iter()
                        .any(|v| !v.is_shared && v.isa_bases.contains(isa_base))
                });
                if has_specific {
                    let isa_base_ident = Ident::new(&isa_base.to_string(), Span::call_site());
                    let enum_name = Ident::new(
                        &format!("{}{}SpecificInstruction", type_prefix, isa_base),
                        Span::call_site(),
                    );
                    Some(quote! { #isa_base_ident(#enum_name) })
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        if !specific_variants.is_empty() {
            let specific_enum_name = Ident::new(
                &format!("{}SpecificInstruction", type_prefix),
                Span::call_site(),
            );
            let specific_doc = format!("{} ISA base specific instructions.", type_prefix);
            main_enums.extend(quote! {
                #[doc = #specific_doc]
                #[derive(Debug, Clone, PartialEq, DeriveInstructionDisplay, DeriveRandom)]
                pub enum #specific_enum_name {
                    #(#specific_variants),*
                }
            });
        }

        // 生成完整的指令类型枚举
        let type_enum_name = Ident::new(&format!("{}Instruction", type_prefix), Span::call_site());
        let type_doc = format!(
            "{} RISC-V instructions, dispatching to shared or specific instructions.",
            type_prefix
        );

        let mut type_variants = Vec::new();
        if !shared_variants.is_empty() {
            let shared_enum_name = Ident::new(
                &format!("{}SharedInstruction", type_prefix),
                Span::call_site(),
            );
            type_variants.push(quote! {
                #[doc = "Instructions shared across ISA bases"]
                Shared(#shared_enum_name)
            });
        }
        if !specific_variants.is_empty() {
            let specific_enum_name = Ident::new(
                &format!("{}SpecificInstruction", type_prefix),
                Span::call_site(),
            );
            type_variants.push(quote! {
                #[doc = "ISA base specific instructions"]
                Specific(#specific_enum_name)
            });
        }

        if !type_variants.is_empty() {
            main_enums.extend(quote! {
                #[doc = #type_doc]
                #[derive(Debug, Clone, PartialEq, DeriveInstructionDisplay, DeriveRandom)]
                pub enum #type_enum_name {
                    #(#type_variants),*
                }
            });
        }

        main_enums
    }

    /// 生成顶层指令枚举
    fn generate_top_level_enum(
        &self,
        rvc_analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        standard_analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
    ) -> TokenStream {
        let mut top_level_variants = Vec::new();

        if !standard_analysis.is_empty() {
            top_level_variants.push(quote! {
                #[doc = "Standard RISC-V instructions"]
                Standard(StandardInstruction)
            });
        }

        if !rvc_analysis.is_empty() {
            top_level_variants.push(quote! {
                #[doc = "RISC-V Compressed instructions"]
                RVC(RVCInstruction)
            });
        }

        quote! {
            /// Main RISC-V instruction enum, dispatching to Standard or RVC instructions.
            #[derive(Debug, Clone, PartialEq, DeriveInstructionDisplay, DeriveRandom)]
            pub enum RiscvInstruction {
                #(#top_level_variants),*
            }
        }
    }

    /// 构建枚举变体
    fn build_variants(
        &self,
        variants: &[&InstructionVariant],
        isa_base_override: Option<&ISABase>,
    ) -> Vec<TokenStream> {
        variants
            .iter()
            .map(|variant| {
                let variant_name = Ident::new(
                    &self.instruction_name_to_variant(&variant.instruction.name),
                    Span::call_site(),
                );

                let attribute_token = match &variant.instruction.assembly_syntax {
                    crate::instruction_types::AssemblySyntax::RustCode(code) => {
                        let code_str = code.as_str();
                        quote! { #[asm_code(#code_str)] }
                    }
                    crate::instruction_types::AssemblySyntax::Format(format_str) => {
                        quote! { #[asm(#format_str)] }
                    }
                };

                if variant.instruction.operands.is_empty() {
                    quote! {
                        #attribute_token
                        #variant_name
                    }
                } else {
                    let operands = variant
                        .instruction
                        .operands
                        .iter()
                        .map(|op| {
                            let op_name = Ident::new(&op.name, Span::call_site());
                            let isa_base =
                                isa_base_override.unwrap_or_else(|| &variant.isa_bases[0]);
                            let op_type_str = self.operand_to_typed_struct(op, isa_base);
                            let op_type: TokenStream = op_type_str
                                .parse()
                                .expect("Failed to parse operand type string");
                            quote! { #op_name: #op_type }
                        })
                        .collect::<Vec<_>>();

                    quote! {
                        #attribute_token
                        #variant_name { #(#operands),* }
                    }
                }
            })
            .collect()
    }

    /// 生成导入语句
    fn generate_imports(&self) -> TokenStream {
        quote! {
            use std::fmt::{self, Display};
            pub use riscv_instruction_types::*;
            use riscv_instruction_macros::{DeriveValidatedValue, DeriveInstructionDisplay, DeriveRandom};
        }
    }

    fn instruction_name_to_variant(&self, name: &str) -> String {
        name.replace('.', "_").replace('-', "_").to_uppercase()
    }

    fn operand_to_typed_struct(&self, operand: &Operand, isa_base: &ISABase) -> String {
        let bit_length = operand.bit_lengths.get(isa_base).unwrap_or(&32);
        let restrictions = operand.restrictions.as_ref();

        match operand.name.as_str() {
            "rd" | "rs1" | "rs2" | "rs3" => {
                if let Some(restriction) = restrictions {
                    if !restriction.forbidden_values.is_empty() {
                        return self.generate_restricted_register_type_name(
                            "IntegerRegister",
                            &restriction.forbidden_values,
                        );
                    }
                }
                "IntegerRegister".to_string()
            }
            "rdp" | "rs1p" | "rs2p" | "rs3p" => {
                if let Some(restriction) = restrictions {
                    if !restriction.forbidden_values.is_empty() {
                        return self.generate_restricted_register_type_name(
                            "CompressedIntegerRegister",
                            &restriction.forbidden_values,
                        );
                    }
                }
                "CompressedIntegerRegister".to_string()
            }
            "fd" | "fs1" | "fs2" | "fs3" => {
                if let Some(restriction) = restrictions {
                    if !restriction.forbidden_values.is_empty() {
                        return self.generate_restricted_register_type_name(
                            "FloatingPointRegister",
                            &restriction.forbidden_values,
                        );
                    }
                }
                "FloatingPointRegister".to_string()
            }
            "fdp" | "fs1p" | "fs2p" | "fs3p" => {
                if let Some(restriction) = restrictions {
                    if !restriction.forbidden_values.is_empty() {
                        return self.generate_restricted_register_type_name(
                            "CompressedFloatingPointRegister",
                            &restriction.forbidden_values,
                        );
                    }
                }
                "CompressedFloatingPointRegister".to_string()
            }

            "imm" | "custom_imm" | "rimm" | "uimm" | "nzimm" | "nzuimm" | "shamt" => {
                if let Some(restriction) = restrictions {
                    if restriction.min_max.is_some()
                        || restriction.multiple_of.is_some()
                        || !restriction.forbidden_values.is_empty()
                    {
                        return self.generate_restricted_immediate_type_name(
                            &operand.name,
                            *bit_length,
                            restriction,
                        );
                    }
                }

                // 默认类型
                match operand.name.as_str() {
                    "uimm" => format!("UImmediate<{}>", bit_length),
                    "nzimm" => format!("NZImmediate<{}>", bit_length),
                    "nzuimm" => format!("NZUImmediate<{}>", bit_length),
                    "shamt" => format!("ShiftAmount<{}>", bit_length),
                    _ => format!("Immediate<{}>", bit_length),
                }
            }

            "csr" => "CSRAddress".to_string(),
            "rm" => "RoundingMode".to_string(),
            "aq" | "rl" => "bool".to_string(),
            "pred" | "succ" | "fm" => "FenceMode".to_string(),

            name => {
                if let Some(restriction) = restrictions {
                    if self.is_immediate_operand(name) {
                        return self.generate_restricted_immediate_type_name(
                            name,
                            *bit_length,
                            restriction,
                        );
                    }
                    if self.is_register_operand(name) && !restriction.forbidden_values.is_empty() {
                        let base_type = self.get_register_base_type(name);
                        return self.generate_restricted_register_type_name(
                            base_type,
                            &restriction.forbidden_values,
                        );
                    }
                }

                // 默认处理
                if name.starts_with("rs") || name.starts_with("rd") {
                    "IntegerRegister".to_string()
                } else if name.starts_with("fs") || name.starts_with("fd") {
                    "FloatingPointRegister".to_string()
                } else if name.ends_with("imm") || name.contains("imm") {
                    format!("Immediate<{}>", bit_length)
                } else {
                    "u32".to_string()
                }
            }
        }
    }

    /// 判断是否为寄存器操作数
    fn is_register_operand(&self, name: &str) -> bool {
        matches!(
            name,
            "rd" | "rs1"
                | "rs2"
                | "rs3"
                | "rdp"
                | "rs1p"
                | "rs2p"
                | "rs3p"
                | "fd"
                | "fs1"
                | "fs2"
                | "fs3"
                | "fdp"
                | "fs1p"
                | "fs2p"
                | "fs3p"
        ) || name.starts_with("rs")
            || name.starts_with("rd")
            || name.starts_with("fs")
            || name.starts_with("fd")
    }

    /// 判断是否为立即数操作数
    fn is_immediate_operand(&self, name: &str) -> bool {
        matches!(
            name,
            "imm" | "custom_imm" | "rimm" | "uimm" | "nzimm" | "nzuimm" | "shamt"
        ) || name.ends_with("imm")
            || name.contains("imm")
    }

    /// 获取寄存器基础类型
    fn get_register_base_type(&self, name: &str) -> &'static str {
        match name {
            "rd" | "rs1" | "rs2" | "rs3" => "IntegerRegister",
            "rdp" | "rs1p" | "rs2p" | "rs3p" => "CompressedIntegerRegister",
            "fd" | "fs1" | "fs2" | "fs3" => "FloatingPointRegister",
            "fdp" | "fs1p" | "fs2p" | "fs3p" => "CompressedFloatingPointRegister",
            _ if name.starts_with("rs") || name.starts_with("rd") => "IntegerRegister",
            _ if name.starts_with("fs") || name.starts_with("fd") => "FloatingPointRegister",
            _ => "IntegerRegister",
        }
    }

    /// 创建立即数类型签名
    fn create_immediate_type_signature(
        &self,
        name: &str,
        bit_length: u8,
        restriction: &crate::instruction_types::OperandRestriction,
    ) -> (String, u8, Option<u8>, Vec<u8>, Option<(i64, i64)>, bool) {
        let base_type = self.get_immediate_base_type(name);
        let is_signed = self.is_signed_immediate(name);
        (
            base_type,
            bit_length,
            restriction.multiple_of,
            restriction.forbidden_values.clone(),
            restriction.min_max,
            is_signed,
        )
    }

    /// 获取立即数基础类型
    fn get_immediate_base_type(&self, name: &str) -> String {
        match name {
            "uimm" => "unsigned".to_string(),
            "nzimm" => "signed_nz".to_string(),
            "nzuimm" => "unsigned_nz".to_string(),
            "shamt" => "shift".to_string(),
            _ if name.starts_with("nz") => "signed_nz".to_string(),
            _ if name.starts_with("u") => "unsigned".to_string(),
            _ => "signed".to_string(),
        }
    }

    /// 判断是否为有符号立即数
    fn is_signed_immediate(&self, name: &str) -> bool {
        !matches!(name, "uimm" | "nzuimm" | "shamt") && !name.starts_with("u")
    }

    /// 生成受限立即数类型定义
    fn generate_restricted_immediate_type_def(
        &self,
        operand_name: &str,
        bit_length: u8,
        restriction: &crate::instruction_types::OperandRestriction,
    ) -> TokenStream {
        let type_name =
            self.generate_restricted_immediate_type_name(operand_name, bit_length, restriction);
        let type_ident = syn::Ident::new(&type_name, proc_macro2::Span::call_site());

        let is_signed = self.is_signed_immediate(operand_name);
        let is_nonzero = operand_name.starts_with("nz") || operand_name.contains("nz");
        let is_shift = operand_name == "shamt";

        let (inner_type, min_expr, max_expr) = if is_shift {
            (
                quote! { u8 },
                quote! { 0 },
                quote! { ((1u16 << #bit_length) - 1) as u8 },
            )
        } else if is_signed {
            (
                quote! { i32 },
                quote! { -(1i32 << (#bit_length - 1)) },
                quote! { (1i32 << (#bit_length - 1)) - 1 },
            )
        } else {
            // For unsigned, pre-calculate min value to avoid "if/else" in the generated attribute string.
            let unsigned_min_val_token = if is_nonzero { quote!(1) } else { quote!(0) };
            (
                quote! { u32 },
                unsigned_min_val_token,
                quote! { ((1u64 << #bit_length) - 1) as u32 },
            )
        };

        // 处理范围约束
        let (final_min_ts, final_max_ts) = if let Some((min, max)) = restriction.min_max {
            if is_signed {
                (quote! { #min as i32 }, quote! { #max as i32 })
            } else {
                (quote! { #min as u32 }, quote! { #max as u32 })
            }
        } else {
            (min_expr, max_expr)
        };

        let final_min_str = final_min_ts.to_string();
        let final_max_str = final_max_ts.to_string();

        // 处理禁用值 - 对于 NZ 类型，确保包含 0
        let mut effective_forbidden_values = restriction.forbidden_values.clone();
        if is_nonzero && !effective_forbidden_values.contains(&0) {
            effective_forbidden_values.push(0);
            effective_forbidden_values.sort();
        }

        let forbidden_values: Vec<proc_macro2::TokenStream> = effective_forbidden_values
            .iter()
            .map(|&v| {
                if is_signed {
                    quote! { #v as i32 }
                } else if is_shift {
                    quote! { #v as u8 }
                } else {
                    quote! { #v as u32 }
                }
            })
            .collect();

        let forbidden_str = effective_forbidden_values
            .iter()
            .map(|v| v.to_string())
            .collect::<Vec<_>>()
            .join(",");

        // 处理倍数约束
        let multiple_attr = if let Some(multiple_val) = restriction.multiple_of {
            let multiple_str = multiple_val.to_string();
            quote! { multiple_of = #multiple_str, }
        } else {
            quote! {}
        };

        let forbidden_attr = if !forbidden_values.is_empty() {
            quote! { forbidden = #forbidden_str, }
        } else {
            quote! {}
        };

        let display_attr = quote! { display = "{}", };

        quote! {
                    #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue, DeriveRandom)]
                    #[validated(
                        min = #final_min_str,
                        max = #final_max_str,
                        name = #type_name,
                        #display_attr
                        #multiple_attr
                        #forbidden_attr
                    )]
                    pub struct #type_ident(#inner_type);
        }
    }

    /// 生成受限立即数类型名称
    fn generate_restricted_immediate_type_name(
        &self,
        operand_name: &str,
        bit_length: u8,
        restriction: &crate::instruction_types::OperandRestriction,
    ) -> String {
        let base_name = match operand_name {
            "uimm" => "UImmediate".to_string(),
            "nzimm" => "NZImmediate".to_string(),
            "nzuimm" => "NZUImmediate".to_string(),
            "shamt" => "ShiftAmount".to_string(),
            _ if operand_name.starts_with("nz") => "NZImmediate".to_string(),
            _ if operand_name.starts_with("u") => "UImmediate".to_string(),
            _ => "Immediate".to_string(),
        };

        let mut modifiers = Vec::new();

        // 添加范围修饰符
        if let Some((min, max)) = restriction.min_max {
            let min_str = if min < 0 {
                format!("Neg{}", min.abs())
            } else {
                min.to_string()
            };
            let max_str = if max < 0 {
                format!("Neg{}", max.abs())
            } else {
                max.to_string()
            };
            modifiers.push(format!("Range{}To{}", min_str, max_str));
        }

        // 添加倍数修饰符
        if let Some(multiple) = restriction.multiple_of {
            modifiers.push(format!("MultipleOf{}", multiple));
        }

        // 添加禁用值修饰符
        if !restriction.forbidden_values.is_empty() {
            let mut sorted_forbidden = restriction.forbidden_values.clone();
            sorted_forbidden.sort();

            if sorted_forbidden.len() == 1 {
                let val = sorted_forbidden[0];
                if val == 0 {
                    modifiers.push("ExceptZero".to_string());
                } else {
                    modifiers.push(format!("Except{}", val));
                }
            } else if sorted_forbidden.len() <= 3 {
                let values_str = sorted_forbidden
                    .iter()
                    .map(|&v| {
                        if v == 0 {
                            "Zero".to_string()
                        } else {
                            v.to_string()
                        }
                    })
                    .collect::<Vec<_>>()
                    .join("And");
                modifiers.push(format!("Except{}", values_str));
            } else {
                modifiers.push(format!("ExceptMultiple{}Values", sorted_forbidden.len()));
            }
        }

        // 组合名称
        if modifiers.is_empty() {
            format!("{}{}", base_name, bit_length)
        } else {
            format!("{}{}{}", base_name, bit_length, modifiers.join(""))
        }
    }

    /// 生成受限寄存器类型定义
    fn generate_restricted_register_type_def(
        &self,
        base_type: &str,
        forbidden_values: &[u8],
    ) -> TokenStream {
        let type_name = self.generate_restricted_register_type_name(base_type, forbidden_values);
        let type_ident = syn::Ident::new(&type_name, proc_macro2::Span::call_site());

        let forbidden_list = forbidden_values
            .iter()
            .map(|v| v.to_string())
            .collect::<Vec<_>>()
            .join(",");

        let (max_val, display_prefix) = match base_type {
            "IntegerRegister" => ("31", "x{}"),
            "FloatingPointRegister" => ("31", "f{}"),
            "CompressedIntegerRegister" => ("15", "x{}"),
            "CompressedFloatingPointRegister" => ("15", "f{}"),
            _ => ("31", "x{}"),
        };

        let (display_attr, display_impl) = if base_type.contains("Compressed") {
            let prefix = if display_prefix.starts_with("x") {
                "x"
            } else {
                "f"
            };
            (
                quote! { skip_display, },
                quote! {
                    impl std::fmt::Display for #type_ident {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, "{}{}", #prefix, self.0)
                        }
                    }
                },
            )
        } else {
            (quote! { display = #display_prefix, }, quote! {})
        };

        quote! {
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue, DeriveRandom)]
            #[validated(min = "0", max = #max_val, name = #type_name, #display_attr forbidden = #forbidden_list)]
            pub struct #type_ident(u8);

            #display_impl
        }
    }

    /// 生成受限寄存器类型名称
    fn generate_restricted_register_type_name(
        &self,
        base_type: &str,
        forbidden_values: &[u8],
    ) -> String {
        let mut sorted_forbidden = forbidden_values.to_vec();
        sorted_forbidden.sort();

        let forbidden_desc = if sorted_forbidden.len() == 1 {
            let val = sorted_forbidden[0];
            if val == 0 {
                "ExceptZero".to_string()
            } else {
                format!("Except{}", val)
            }
        } else if sorted_forbidden.len() <= 3 {
            let values_str = sorted_forbidden
                .iter()
                .map(|&v| {
                    if v == 0 {
                        "Zero".to_string()
                    } else {
                        v.to_string()
                    }
                })
                .collect::<Vec<_>>()
                .join("And");
            format!("Except{}", values_str)
        } else if sorted_forbidden.len() <= 5 {
            let values_str = sorted_forbidden
                .iter()
                .map(|v| format!("R{}", v))
                .collect::<Vec<_>>()
                .join("_");
            format!("ExceptRegs{}", values_str)
        } else {
            let count = sorted_forbidden.len();
            if self.is_consecutive_range(&sorted_forbidden) {
                let start = sorted_forbidden[0];
                let end = sorted_forbidden[sorted_forbidden.len() - 1];
                format!("ExceptRange{}To{}", start, end)
            } else {
                format!("ExceptMultiple{}Regs", count)
            }
        };

        format!("{}{}", base_type, forbidden_desc)
    }

    fn is_consecutive_range(&self, values: &[u8]) -> bool {
        if values.len() < 2 {
            return false;
        }

        for i in 1..values.len() {
            if values[i] != values[i - 1] + 1 {
                return false;
            }
        }
        true
    }
}
