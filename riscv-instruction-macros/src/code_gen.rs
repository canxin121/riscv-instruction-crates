use crate::instruction_types::{ISABase, ISAExtension, Instruction, Operand};
use proc_macro2::{Span, TokenStream};
use quote::quote;
use std::collections::{HashMap, HashSet};
use syn::Ident;

// InstructionVariant 结构体保持不变，因为它只用于数据分析
#[derive(Debug, Clone)]
struct InstructionVariant {
    instruction: Instruction,
    isa_bases: Vec<ISABase>,
    is_shared: bool,
}

pub struct CodeGenerator {
    rvc_instructions: Vec<Instruction>,
    standard_instructions: Vec<Instruction>,
}

impl CodeGenerator {
    // new 函数保持不变
    pub fn new(
        rvc_instructions: Vec<Instruction>,
        standard_instructions: Vec<Instruction>,
    ) -> Self {
        Self {
            rvc_instructions,
            standard_instructions,
        }
    }

    /// 主生成函数，现在返回 TokenStream
    pub fn generate_instruction_enum(&self) -> TokenStream {
        // 分别分析 RVC 和 Standard 指令的共享性
        let rvc_analysis = self.analyze_instruction_sharing_for_type(&self.rvc_instructions);
        let standard_analysis = self.analyze_instruction_sharing_for_type(&self.standard_instructions);

        // 调用各个子生成函数
        let imports = self.generate_imports();
        let operand_types = self.generate_operand_types();
        let rvc_enums = self.generate_instruction_type_enums(&rvc_analysis, "RVC");
        let standard_enums = self.generate_instruction_type_enums(&standard_analysis, "Standard");
        let main_enum = self.generate_top_level_enum(&rvc_analysis, &standard_analysis);

        // 使用 quote! 宏将所有 TokenStream 片段组合成一个文件
        quote! {
            // This file is auto-generated by the RISC-V instruction code generator.
            // Author: canxin121 <q1969730106@gmail.com>
            // Do not edit this file manually.
            #imports

            // --- RVC Instruction Enums ---
            #rvc_enums

            // --- Standard Instruction Enums ---
            #standard_enums

            // --- Top Level Enums ---
            #main_enum

            // --- Tipos de Operandos y Traits ---
            #operand_types
        }
    }

    /// 为特定指令类型分析指令共享性
    fn analyze_instruction_sharing_for_type(&self, instructions: &[Instruction]) -> HashMap<ISAExtension, Vec<InstructionVariant>> {
        let mut analysis: HashMap<ISAExtension, Vec<InstructionVariant>> = HashMap::new();
        let mut by_extension: HashMap<ISAExtension, Vec<&Instruction>> = HashMap::new();
        
        for inst in instructions {
            by_extension.entry(inst.extension).or_default().push(inst);
        }
        
        for (extension, instructions) in by_extension {
            let mut variants = Vec::new();
            let mut processed_names = HashSet::new();
            
            for &inst in &instructions {
                if processed_names.contains(&inst.name) {
                    continue;
                }
                processed_names.insert(&inst.name);
                
                let same_name_instructions: Vec<&Instruction> = instructions
                    .iter()
                    .filter(|&&i| i.name == inst.name)
                    .copied()
                    .collect();
                
                if same_name_instructions.len() == 1 {
                    variants.push(InstructionVariant {
                        instruction: inst.clone(),
                        isa_bases: inst.isa_bases.clone(),
                        is_shared: inst.isa_bases.len() > 1,
                    });
                } else {
                    let is_identical = self.are_instructions_identical(&same_name_instructions);
                    if is_identical {
                        let mut merged_isa_bases = Vec::new();
                        for inst in &same_name_instructions {
                            for &isa_base in &inst.isa_bases {
                                if !merged_isa_bases.contains(&isa_base) {
                                    merged_isa_bases.push(isa_base);
                                }
                            }
                        }
                        let mut merged_inst = inst.clone();
                        merged_inst.isa_bases = merged_isa_bases.clone();
                        variants.push(InstructionVariant {
                            instruction: merged_inst,
                            isa_bases: merged_isa_bases.clone(),
                            is_shared: merged_isa_bases.len() > 1,
                        });
                    } else {
                        for &different_inst in &same_name_instructions {
                            variants.push(InstructionVariant {
                                instruction: different_inst.clone(),
                                isa_bases: different_inst.isa_bases.clone(),
                                is_shared: false,
                            });
                        }
                    }
                }
            }
            analysis.insert(extension, variants);
        }
        analysis
    }

    fn are_instructions_identical(&self, instructions: &[&Instruction]) -> bool {
        if instructions.len() <= 1 {
            return true;
        }
        let first = instructions[0];
        for &inst in &instructions[1..] {
            if first.operands.len() != inst.operands.len() {
                return false;
            }
            for (op1, op2) in first.operands.iter().zip(inst.operands.iter()) {
                if op1.name != op2.name {
                    return false;
                }
                for &isa_base in &[ISABase::RV32, ISABase::RV64] {
                    if op1.bit_lengths.get(&isa_base) != op2.bit_lengths.get(&isa_base) {
                        return false;
                    }
                }
            }
            if first.assembly_syntax != inst.assembly_syntax {
                return false;
            }
        }
        true
    }

    /// 生成特定指令类型的所有枚举 (RVC 或 Standard)
    fn generate_instruction_type_enums(&self, analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>, type_prefix: &str) -> TokenStream {
        let mut all_enums = TokenStream::new();
        
        // 生成共享指令枚举
        let shared_enums = self.generate_shared_instructions_enum_for_type(analysis, type_prefix);
        all_enums.extend(shared_enums);
        
        // 生成 ISA 特定指令枚举
        let specific_enums = self.generate_isa_specific_instructions_enum_for_type(analysis, type_prefix);
        all_enums.extend(specific_enums);
        
        // 生成该类型的主枚举 (Shared + Specific)
        let main_enums = self.generate_type_main_enum(analysis, type_prefix);
        all_enums.extend(main_enums);
        
        all_enums
    }

    /// 生成特定类型的共享指令枚举
    fn generate_shared_instructions_enum_for_type(&self, analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>, type_prefix: &str) -> TokenStream {
        let mut all_enums = TokenStream::new();
        for (extension, variants) in analysis {
            let shared_variants: Vec<_> = variants.iter().filter(|v| v.is_shared).collect();
            if shared_variants.is_empty() {
                continue;
            }

            let enum_name = Ident::new(&format!("{}{}SharedInstructions", type_prefix, extension), Span::call_site());
            let doc_comment = format!("{} shared instructions for {} extension", type_prefix, extension);
            
            let variant_tokens = self.build_variants(&shared_variants, None);

            all_enums.extend(quote! {
                #[doc = #doc_comment]
                #[derive(Debug, Clone, PartialEq, InstructionDisplay)]
                #[rustfmt::skip]
                pub enum #enum_name {
                    #(#variant_tokens),*
                }
            });
        }
        all_enums
    }

    /// 生成特定类型的 ISA 特定指令枚举
    fn generate_isa_specific_instructions_enum_for_type(&self, analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>, type_prefix: &str) -> TokenStream {
        let mut all_enums = TokenStream::new();
        for isa_base in &[ISABase::RV32, ISABase::RV64] {
            for (extension, variants) in analysis {
                let isa_specific_variants: Vec<_> = variants
                    .iter()
                    .filter(|v| !v.is_shared && v.isa_bases.contains(isa_base))
                    .collect();

                if isa_specific_variants.is_empty() {
                    continue;
                }

                let enum_name = Ident::new(&format!("{}{}{}SpecificInstructions", type_prefix, isa_base, extension), Span::call_site());
                let doc_comment = format!("{} {} specific instructions for {} extension", type_prefix, isa_base, extension);
                
                let variant_tokens = self.build_variants(&isa_specific_variants, Some(isa_base));

                all_enums.extend(quote! {
                    #[doc = #doc_comment]
                    #[derive(Debug, Clone, PartialEq, InstructionDisplay)]
                    #[rustfmt::skip]
                    pub enum #enum_name {
                        #(#variant_tokens),*
                    }
                });
            }
        }
        all_enums
    }

    /// 生成特定类型的主枚举 (Shared + Specific)
    fn generate_type_main_enum(&self, analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>, type_prefix: &str) -> TokenStream {
        let mut main_enums = TokenStream::new();

        // --- TypeSharedInstruction Enum ---
        let shared_variants = analysis.iter().filter_map(|(ext, vars)| {
            if vars.iter().any(|v| v.is_shared) {
                let ext_ident = Ident::new(&ext.to_string(), Span::call_site());
                let enum_name = Ident::new(&format!("{}{}SharedInstructions", type_prefix, ext), Span::call_site());
                Some(quote! { #ext_ident(#enum_name) })
            } else {
                None
            }
        }).collect::<Vec<_>>();
        
        if !shared_variants.is_empty() {
            let shared_enum_name = Ident::new(&format!("{}SharedInstruction", type_prefix), Span::call_site());
            let shared_doc = format!("{} instructions shared across all ISA bases, grouped by extension.", type_prefix);
            main_enums.extend(quote!{
                #[doc = #shared_doc]
                #[derive(Debug, Clone, PartialEq, InstructionDisplay)]
                pub enum #shared_enum_name {
                    #(#shared_variants),*
                }
            });
        }

        // --- ISA-specific Enums ---
        for isa_base in &[ISABase::RV32, ISABase::RV64] {
            let isa_base_str = isa_base.to_string();
            let specific_enum_name = Ident::new(&format!("{}{}SpecificInstruction", type_prefix, isa_base), Span::call_site());
            let doc_comment = format!("{} {} specific instructions, grouped by extension.", type_prefix, isa_base_str);
            
            let extension_variants = analysis.iter().filter_map(|(ext, vars)| {
                 if vars.iter().any(|v| !v.is_shared && v.isa_bases.contains(isa_base)) {
                    let ext_ident = Ident::new(&ext.to_string(), Span::call_site());
                    let enum_name = Ident::new(&format!("{}{}{}SpecificInstructions", type_prefix, isa_base, ext), Span::call_site());
                    Some(quote! { #ext_ident(#enum_name) })
                } else {
                    None
                }
            }).collect::<Vec<_>>();

            if !extension_variants.is_empty() {
                 main_enums.extend(quote!{
                    #[doc = #doc_comment]
                    #[derive(Debug, Clone, PartialEq, InstructionDisplay)]
                    pub enum #specific_enum_name {
                        #(#extension_variants),*
                    }
                });
            }
        }
        
        // --- TypeSpecificInstruction Enum ---
        let specific_variants = [ISABase::RV32, ISABase::RV64].iter().filter_map(|isa_base| {
            let has_specific = analysis.values().any(|vars| vars.iter().any(|v| !v.is_shared && v.isa_bases.contains(isa_base)));
            if has_specific {
                let isa_base_ident = Ident::new(&isa_base.to_string(), Span::call_site());
                let enum_name = Ident::new(&format!("{}{}SpecificInstruction", type_prefix, isa_base), Span::call_site());
                Some(quote! { #isa_base_ident(#enum_name) })
            } else {
                None
            }
        }).collect::<Vec<_>>();

        if !specific_variants.is_empty() {
            let specific_enum_name = Ident::new(&format!("{}SpecificInstruction", type_prefix), Span::call_site());
            let specific_doc = format!("{} ISA base specific instructions.", type_prefix);
            main_enums.extend(quote!{
                #[doc = #specific_doc]
                #[derive(Debug, Clone, PartialEq, InstructionDisplay)]
                pub enum #specific_enum_name {
                    #(#specific_variants),*
                }
            });
        }

        // --- Complete Type Instruction Enum ---
        let type_enum_name = Ident::new(&format!("{}Instruction", type_prefix), Span::call_site());
        let type_doc = format!("{} RISC-V instructions, dispatching to shared or specific instructions.", type_prefix);
        
        let mut type_variants = Vec::new();
        if !shared_variants.is_empty() {
            let shared_enum_name = Ident::new(&format!("{}SharedInstruction", type_prefix), Span::call_site());
            type_variants.push(quote! {
                #[doc = "Instructions shared across ISA bases"]
                Shared(#shared_enum_name)
            });
        }
        if !specific_variants.is_empty() {
            let specific_enum_name = Ident::new(&format!("{}SpecificInstruction", type_prefix), Span::call_site());
            type_variants.push(quote! {
                #[doc = "ISA base specific instructions"]
                Specific(#specific_enum_name)
            });
        }

        if !type_variants.is_empty() {
            main_enums.extend(quote! {
                #[doc = #type_doc]
                #[derive(Debug, Clone, PartialEq, InstructionDisplay)]
                pub enum #type_enum_name {
                    #(#type_variants),*
                }
            });
        }

        main_enums
    }

    /// 生成最顶层的指令枚举
    fn generate_top_level_enum(&self, rvc_analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>, standard_analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>) -> TokenStream {
        let mut top_level_variants = Vec::new();
        
        // 检查是否有 Standard 指令
        if !standard_analysis.is_empty() {
            top_level_variants.push(quote! {
                #[doc = "Standard RISC-V instructions"]
                Standard(StandardInstruction)
            });
        }
        
        // 检查是否有 RVC 指令
        if !rvc_analysis.is_empty() {
            top_level_variants.push(quote! {
                #[doc = "RISC-V Compressed instructions"]
                RVC(RVCInstruction)
            });
        }

        quote! {
            /// Main RISC-V instruction enum, dispatching to Standard or RVC instructions.
            #[derive(Debug, Clone, PartialEq, InstructionDisplay)]
            pub enum RiscvInstruction {
                #(#top_level_variants),*
            }
        }
    }

    /// 辅助函数，用于构建枚举的变体列表
    fn build_variants(&self, variants: &[&InstructionVariant], isa_base_override: Option<&ISABase>) -> Vec<TokenStream> {
        variants.iter().map(|variant| {
            let variant_name = Ident::new(&self.instruction_name_to_variant(&variant.instruction.name), Span::call_site());
            let asm_syntax = variant.instruction.assembly_syntax.trim();

            if variant.instruction.operands.is_empty() {
                quote! {
                    #[asm(#asm_syntax)]
                    #variant_name
                }
            } else {
                let operands = variant.instruction.operands.iter().map(|op| {
                    let op_name = Ident::new(&op.name, Span::call_site());
                    // 如果提供了 override，使用它；否则，从变体中取第一个
                    let isa_base = isa_base_override.unwrap_or_else(|| &variant.isa_bases[0]);
                    let op_type_str = self.operand_to_typed_struct(op, isa_base);
                    let op_type: TokenStream = op_type_str.parse().expect("Failed to parse operand type string");
                    quote! { #op_name: #op_type }
                }).collect::<Vec<_>>();

                quote! {
                    #[asm(#asm_syntax)]
                    #variant_name { #(#operands),* }
                }
            }
        }).collect()
    }

    /// 生成 use 语句
    fn generate_imports(&self) -> TokenStream {
        quote! {
            use std::fmt::{self, Display};
            // 假设这两个宏在 riscv-instruction-macros crate 内或其依赖项中可用
            use riscv_instruction_macros::{DeriveValidatedValue, InstructionDisplay};
        }
    }

    /// 生成操作数相关的类型定义
    fn generate_operand_types(&self) -> TokenStream {
        // 使用 quote! 包裹静态的 Rust 代码字符串
        quote! {
            /// Common trait for validated value types
            pub trait ValidatedValue<T> {
                const MIN: T;
                const MAX: T;
                type Error;
                fn new(value: T) -> Result<Self, Self::Error> where Self: Sized;
                fn get(&self) -> T;
                fn set(&mut self, value: T) -> Result<(), Self::Error>;
            }
            
            /// Register identifier with bit length validation
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "0", max = "((1u16 << BITS) - 1) as u8", name = "Register", display = "x{}")]
            pub struct Register<const BITS: u8>(u8);

            /// Immediate value with bit length validation
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "-(1i32 << (BITS - 1))", max = "(1i32 << (BITS - 1)) - 1", name = "Immediate")]
            pub struct Immediate<const BITS: u8>(i32);

            /// Unsigned immediate value with bit length validation
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "0", max = "((1u64 << BITS) - 1) as u32", name = "Unsigned immediate")]
            pub struct UImmediate<const BITS: u8>(u32);

            /// Non-zero immediate value with bit length validation
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "-(1i32 << (BITS - 1))", max = "(1i32 << (BITS - 1)) - 1", name = "Non-zero immediate", not_zero)]
            pub struct NZImmediate<const BITS: u8>(i32);
            
            /// Non-zero unsigned immediate value with bit length validation
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "1", max = "((1u64 << BITS) - 1) as u32", name = "Non-zero unsigned immediate", not_zero)]
            pub struct NZUImmediate<const BITS: u8>(u32);

            /// Shift amount with bit length validation
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "0", max = "((1u16 << BITS) - 1) as u8", name = "Shift amount")]
            pub struct ShiftAmount<const BITS: u8>(u8);

            /// CSR address
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "0", max = "0xFFF", name = "CSR address", display = "0x{:x}")]
            pub struct CSRAddress(u16);

            /// Rounding mode
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "0", max = "7", name = "Rounding mode")]
            pub struct RoundingMode(u8);

            /// Fence mode
            #[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
            #[validated(min = "0", max = "15", name = "Fence mode")]
            pub struct FenceMode(u8);

            /// Boolean value that displays as 0 or 1
            #[derive(Debug, Clone, Copy, PartialEq, Eq)]
            pub struct Bool(bool);

            impl ValidatedValue<bool> for Bool {
                const MIN: bool = false;
                const MAX: bool = true;
                type Error = String;
                fn new(value: bool) -> Result<Self, Self::Error> { Ok(Self(value)) }
                fn get(&self) -> bool { self.0 }
                fn set(&mut self, value: bool) -> Result<(), Self::Error> { self.0 = value; Ok(()) }
            }

            impl Display for Bool {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    write!(f, "{}", if self.0 { "1" } else { "0" })
                }
            }
        }
    }

    // instruction_name_to_variant 和 operand_to_typed_struct 保持不变，
    // 它们是纯粹的字符串处理帮助函数。
    fn instruction_name_to_variant(&self, name: &str) -> String {
        name.replace('.', "_").replace('-', "_").to_uppercase()
    }

    fn operand_to_typed_struct(&self, operand: &Operand, isa_base: &ISABase) -> String {
        let bit_length = operand.bit_lengths.get(isa_base).unwrap_or(&32);
        match operand.name.as_str() {
            name if name.starts_with("rs") || name.starts_with("rd") => {
                format!("Register<{}>", bit_length)
            }
            "imm" => format!("Immediate<{}>", bit_length),
            "uimm" => format!("UImmediate<{}>", bit_length),
            "nzimm" => format!("NZImmediate<{}>", bit_length),
            "nzuimm" => format!("NZUImmediate<{}>", bit_length),
            "shamt" => format!("ShiftAmount<{}>", bit_length),
            "csr" => "CSRAddress".to_string(),
            "rm" => "RoundingMode".to_string(),
            "aq" | "rl" => "Bool".to_string(),
            "pred" | "succ" | "fm" => "FenceMode".to_string(),
            _ => "u32".to_string(), // Fallback
        }
    }
}