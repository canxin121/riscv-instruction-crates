use code_gen::CodeGenerator;
use serde::{Deserialize, Serialize};
use types::Instruction;

#[derive(Debug, Clone, Serialize, Deserialize)]
struct RiscvInstruction {
    rvc_instructions: Vec<Instruction>,
    standard_instructions: Vec<Instruction>,
}

fn main() {
    let file = "assets/riscv_instructions.json";
    let output_file = "generated_instructions.rs";

    let file_content = std::fs::read_to_string(file).expect("Failed to read the file");
    let instructions: RiscvInstruction =
        serde_json::from_str(&file_content).expect("Failed to parse JSON");

    // 创建代码生成器
    let code_generator = CodeGenerator::new(
        instructions.rvc_instructions.clone(),
        instructions.standard_instructions.clone(),
    );

    // 生成代码
    let generated_code = code_generator.generate_instruction_enum();

    // 写入生成的代码到文件
    std::fs::write(output_file, generated_code).expect("Failed to write generated code");
}

pub mod code_gen {
    use std::collections::{HashMap, HashSet};

    use crate::types::*;

    #[derive(Debug, Clone)]
    struct InstructionVariant {
        instruction: Instruction,
        isa_bases: Vec<ISABase>,
        is_shared: bool,
    }

    pub struct CodeGenerator {
        rvc_instructions: Vec<Instruction>,
        standard_instructions: Vec<Instruction>,
    }

    impl CodeGenerator {
        pub fn new(
            rvc_instructions: Vec<Instruction>,
            standard_instructions: Vec<Instruction>,
        ) -> Self {
            Self {
                rvc_instructions,
                standard_instructions,
            }
        }

        pub fn generate_instruction_enum(&self) -> String {
            let mut code = String::new();

            // 加入自动生成说明, 加入作者canxin121 q1969730106@gmail.com
            code.push_str(
                "// This file is auto-generated by the RISC-V instruction code generator.\n",
            );
            code.push_str("// Author: canxin121 <q1969730106@gmail.com>\n");
            code.push_str("// Do not edit this file manually.\n\n");
            // 添加编译器属性
            code.push_str("#![allow(non_camel_case_types)]\n\n");

            // 生成必要的导入
            code.push_str(&self.generate_imports());

            // 分析指令共享性
            let instruction_analysis = self.analyze_instruction_sharing();

            // 生成主要的指令Enum（顶层）
            code.push_str(&self.generate_main_enum(&instruction_analysis));

            // 生成中层枚举：共享指令和特定指令
            code.push_str(&self.generate_shared_instructions_enum(&instruction_analysis));

            // 生成底层枚举：ISA特定指令枚举
            code.push_str(&self.generate_isa_specific_instructions_enum(&instruction_analysis));

            // 为主要Enum实现Display trait
            code.push_str(&self.generate_display_impl(&instruction_analysis));

            // 生成operand相关的结构体和enum（数据类型放在最后）
            code.push_str(&self.generate_operand_types());

            code
        }

        fn analyze_instruction_sharing(&self) -> HashMap<ISAExtension, Vec<InstructionVariant>> {
            let mut analysis: HashMap<ISAExtension, Vec<InstructionVariant>> = HashMap::new();

            // 收集所有指令
            let all_instructions: Vec<&Instruction> = self
                .rvc_instructions
                .iter()
                .chain(self.standard_instructions.iter())
                .collect();

            // 按扩展分组
            let mut by_extension: HashMap<ISAExtension, Vec<&Instruction>> = HashMap::new();
            for inst in &all_instructions {
                by_extension.entry(inst.extension).or_default().push(inst);
            }

            // 分析每个扩展内的指令共享性
            for (extension, instructions) in by_extension {
                let mut variants = Vec::new();
                let mut processed_names = HashSet::new();

                for &inst in &instructions {
                    if processed_names.contains(&inst.name) {
                        continue;
                    }
                    processed_names.insert(&inst.name);

                    // 查找相同名称的所有指令版本
                    let same_name_instructions: Vec<&Instruction> = instructions
                        .iter()
                        .filter(|&&i| i.name == inst.name)
                        .copied()
                        .collect();

                    if same_name_instructions.len() == 1 {
                        // 只有一个版本，直接使用
                        variants.push(InstructionVariant {
                            instruction: inst.clone(),
                            isa_bases: inst.isa_bases.clone(),
                            is_shared: inst.isa_bases.len() > 1,
                        });
                    } else {
                        // 多个版本，检查是否完全相同
                        let is_identical = self.are_instructions_identical(&same_name_instructions);

                        if is_identical {
                            // 完全相同，合并ISABase
                            let mut merged_isa_bases = Vec::new();
                            for inst in &same_name_instructions {
                                for &isa_base in &inst.isa_bases {
                                    if !merged_isa_bases.contains(&isa_base) {
                                        merged_isa_bases.push(isa_base);
                                    }
                                }
                            }

                            let mut merged_inst = inst.clone();
                            merged_inst.isa_bases = merged_isa_bases.clone();

                            variants.push(InstructionVariant {
                                instruction: merged_inst,
                                isa_bases: merged_isa_bases.clone(),
                                is_shared: merged_isa_bases.len() > 1,
                            });
                        } else {
                            // 不相同，为每个版本创建变体
                            for &different_inst in &same_name_instructions {
                                variants.push(InstructionVariant {
                                    instruction: different_inst.clone(),
                                    isa_bases: different_inst.isa_bases.clone(),
                                    is_shared: false,
                                });
                            }
                        }
                    }
                }

                analysis.insert(extension, variants);
            }

            analysis
        }

        fn are_instructions_identical(&self, instructions: &[&Instruction]) -> bool {
            if instructions.len() <= 1 {
                return true;
            }

            let first = instructions[0];
            for &inst in &instructions[1..] {
                // 检查操作数数量
                if first.operands.len() != inst.operands.len() {
                    return false;
                }

                // 检查每个操作数
                for (op1, op2) in first.operands.iter().zip(inst.operands.iter()) {
                    if op1.name != op2.name {
                        return false;
                    }

                    // 检查在所有ISABase上的bit_lengths是否相同
                    for &isa_base in &[ISABase::RV32, ISABase::RV64] {
                        if op1.bit_lengths.get(&isa_base) != op2.bit_lengths.get(&isa_base) {
                            return false;
                        }
                    }
                }

                // 检查汇编语法
                if first.assembly_syntax != inst.assembly_syntax {
                    return false;
                }
            }

            true
        }

        fn generate_shared_instructions_enum(
            &self,
            analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        ) -> String {
            let mut code = String::new();

            for (extension, variants) in analysis {
                let shared_variants: Vec<_> = variants.iter().filter(|v| v.is_shared).collect();

                if shared_variants.is_empty() {
                    continue;
                }

                let enum_name = format!("{}SharedInstructions", extension);
                code.push_str(&format!(
                    "/// Shared instructions for {} extension\n",
                    extension
                ));
                code.push_str("#[derive(Debug, Clone, PartialEq, InstructionDisplay)]\n");
                code.push_str("#[rustfmt::skip]\n");
                code.push_str(&format!("pub enum {} {{\n", enum_name));

                for variant in &shared_variants {
                    let variant_name = self.instruction_name_to_variant(&variant.instruction.name);
                    let asm_syntax = variant.instruction.assembly_syntax.trim();

                    if variant.instruction.operands.is_empty() {
                        code.push_str(&format!("    #[asm(\"{}\")]\n", asm_syntax));
                        code.push_str(&format!("    {},\n", variant_name));
                    } else {
                        code.push_str(&format!("    #[asm(\"{}\")]\n", asm_syntax));

                        // 生成单行字段格式
                        let operands: Vec<String> = variant
                            .instruction
                            .operands
                            .iter()
                            .map(|operand| {
                                let first_isa_base = &variant.isa_bases[0];
                                let operand_type =
                                    self.operand_to_typed_struct(operand, first_isa_base);
                                format!("{}: {}", operand.name, operand_type)
                            })
                            .collect();

                        code.push_str(&format!(
                            "    {} {{{}}},\n",
                            variant_name,
                            operands.join(", ")
                        ));
                    }
                }

                code.push_str("}\n\n");
            }

            code
        }

        fn generate_isa_specific_instructions_enum(
            &self,
            analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        ) -> String {
            let mut code = String::new();

            for isa_base in &[ISABase::RV32, ISABase::RV64] {
                for (extension, variants) in analysis {
                    let isa_specific_variants: Vec<_> = variants
                        .iter()
                        .filter(|v| !v.is_shared && v.isa_bases.contains(isa_base))
                        .collect();

                    if isa_specific_variants.is_empty() {
                        continue;
                    }

                    let enum_name = format!("{}{}SpecificInstructions", isa_base, extension);

                    code.push_str(&format!(
                        "/// {} specific instructions for {} extension\n",
                        isa_base, extension
                    ));
                    code.push_str("#[derive(Debug, Clone, PartialEq, InstructionDisplay)]\n");
                    code.push_str("#[rustfmt::skip]\n");
                    code.push_str(&format!("pub enum {} {{\n", enum_name));

                    for variant in &isa_specific_variants {
                        let variant_name =
                            self.instruction_name_to_variant(&variant.instruction.name);
                        let asm_syntax = variant.instruction.assembly_syntax.trim();

                        if variant.instruction.operands.is_empty() {
                            code.push_str(&format!("    #[asm(\"{}\")]\n", asm_syntax));
                            code.push_str(&format!("    {},\n", variant_name));
                        } else {
                            code.push_str(&format!("    #[asm(\"{}\")]\n", asm_syntax));

                            // 生成单行字段格式
                            let operands: Vec<String> = variant
                                .instruction
                                .operands
                                .iter()
                                .map(|operand| {
                                    let operand_type =
                                        self.operand_to_typed_struct(operand, isa_base);
                                    format!("{}: {}", operand.name, operand_type)
                                })
                                .collect();

                            code.push_str(&format!(
                                "    {} {{{}}},\n",
                                variant_name,
                                operands.join(", ")
                            ));
                        }
                    }

                    code.push_str("}\n\n");
                }
            }

            code
        }

        fn generate_main_enum(
            &self,
            analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        ) -> String {
            let mut code = String::new();
            code.push_str("/// Main RISC-V instruction enum\n");
            code.push_str("#[derive(Debug, Clone, PartialEq, InstructionDisplay)]\n");
            code.push_str("pub enum RiscvInstruction {\n");

            // 添加通用指令（共享指令）
            code.push_str("    /// Instructions shared across ISA bases\n");
            code.push_str("    Shared(SharedInstruction),\n");

            // 添加ISA特定指令
            code.push_str("    /// ISA base specific instructions\n");
            code.push_str("    Specific(SpecificInstruction),\n");

            code.push_str("}\n\n");

            // 生成共享指令枚举
            code.push_str("/// Shared instructions across all ISA bases\n");
            code.push_str("#[derive(Debug, Clone, PartialEq, InstructionDisplay)]\n");
            code.push_str("pub enum SharedInstruction {\n");

            for (extension, variants) in analysis {
                let shared_variants: Vec<_> = variants.iter().filter(|v| v.is_shared).collect();
                if !shared_variants.is_empty() {
                    let shared_enum_name = format!("{}SharedInstructions", extension);
                    code.push_str(&format!("    {}({}),\n", extension, shared_enum_name));
                }
            }

            code.push_str("}\n\n");

            // 生成ISA特定指令枚举
            code.push_str("/// ISA base specific instructions\n");
            code.push_str("#[derive(Debug, Clone, PartialEq, InstructionDisplay)]\n");
            code.push_str("pub enum SpecificInstruction {\n");

            for isa_base in &[ISABase::RV32, ISABase::RV64] {
                let has_specific_instructions = analysis.values().any(|variants| {
                    variants
                        .iter()
                        .any(|v| !v.is_shared && v.isa_bases.contains(isa_base))
                });

                if has_specific_instructions {
                    code.push_str(&format!(
                        "    {}({}SpecificInstruction),\n",
                        isa_base, isa_base
                    ));
                }
            }

            code.push_str("}\n\n");

            // 为每个ISA base生成指令枚举
            for isa_base in &[ISABase::RV32, ISABase::RV64] {
                let has_specific_instructions = analysis.values().any(|variants| {
                    variants
                        .iter()
                        .any(|v| !v.is_shared && v.isa_bases.contains(isa_base))
                });

                if has_specific_instructions {
                    code.push_str(&format!("/// {} specific instructions\n", isa_base));
                    code.push_str("#[derive(Debug, Clone, PartialEq, InstructionDisplay)]\n");
                    code.push_str(&format!("pub enum {}SpecificInstruction {{\n", isa_base));

                    for (extension, variants) in analysis {
                        let isa_specific_variants: Vec<_> = variants
                            .iter()
                            .filter(|v| !v.is_shared && v.isa_bases.contains(isa_base))
                            .collect();

                        if !isa_specific_variants.is_empty() {
                            let isa_enum_name =
                                format!("{}{}SpecificInstructions", isa_base, extension);
                            code.push_str(&format!("    {}({}),\n", extension, isa_enum_name));
                        }
                    }

                    code.push_str("}\n\n");
                }
            }

            code
        }

        fn generate_imports(&self) -> String {
            r#"use std::fmt::{self, Display};
use riscv_instruction_macros::{DeriveValidatedValue, InstructionDisplay};

"#
            .to_string()
        }

        fn generate_display_impl(
            &self,
            _analysis: &HashMap<ISAExtension, Vec<InstructionVariant>>,
        ) -> String {
            // 现在所有Display实现都通过InstructionDisplay derive宏自动生成
            // 返回空字符串，不再手动生成Display实现
            String::new()
        }

        fn generate_operand_types(&self) -> String {
            let mut code = String::new();

            // 首先定义通用的 trait
            code.push_str(
                r#"/// Common trait for validated value types
pub trait ValidatedValue<T> {
    const MIN: T;
    const MAX: T;
    type Error;

    /// Create a new validated value
    fn new(value: T) -> Result<Self, Self::Error>
    where
        Self: Sized;

    /// Get the current value
    fn get(&self) -> T;

    /// Set a new value with validation
    fn set(&mut self, value: T) -> Result<(), Self::Error>;
}

/// Register identifier with bit length validation
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "0",
    max = "((1u16 << BITS) - 1) as u8",
    name = "Register",
    display = "x{}"
)]
pub struct Register<const BITS: u8>(u8);

/// Immediate value with bit length validation
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "-(1i32 << (BITS - 1))",
    max = "(1i32 << (BITS - 1)) - 1",
    name = "Immediate"
)]
pub struct Immediate<const BITS: u8>(i32);

/// Unsigned immediate value with bit length validation
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "0",
    max = "((1u64 << BITS) - 1) as u32",
    name = "Unsigned immediate"
)]
pub struct UImmediate<const BITS: u8>(u32);

/// Non-zero immediate value with bit length validation
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "-(1i32 << (BITS - 1))",
    max = "(1i32 << (BITS - 1)) - 1",
    name = "Non-zero immediate",
    not_zero
)]
pub struct NZImmediate<const BITS: u8>(i32);

/// Non-zero unsigned immediate value with bit length validation
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "1",
    max = "((1u64 << BITS) - 1) as u32",
    name = "Non-zero unsigned immediate",
    not_zero
)]
pub struct NZUImmediate<const BITS: u8>(u32);

/// Shift amount with bit length validation
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "0",
    max = "((1u16 << BITS) - 1) as u8",
    name = "Shift amount"
)]
pub struct ShiftAmount<const BITS: u8>(u8);

/// CSR address
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "0",
    max = "0xFFF",
    name = "CSR address",
    display = "0x{:x}"
)]
pub struct CSRAddress(u16);

/// Rounding mode
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "0",
    max = "7",
    name = "Rounding mode"
)]
pub struct RoundingMode(u8);

/// Fence mode
#[derive(Debug, Clone, Copy, PartialEq, Eq, DeriveValidatedValue)]
#[validated(
    min = "0",
    max = "15",
    name = "Fence mode"
)]
pub struct FenceMode(u8);

/// Boolean value that displays as 0 or 1
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Bool(bool);

impl ValidatedValue<bool> for Bool {
    const MIN: bool = false;
    const MAX: bool = true;
    type Error = String;
    
    fn new(value: bool) -> Result<Self, Self::Error> {
        Ok(Self(value))
    }

    fn get(&self) -> bool {
        self.0
    }

    fn set(&mut self, value: bool) -> Result<(), Self::Error> {
        self.0 = value;
        Ok(())
    }
}

impl Display for Bool {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", if self.0 { "1" } else { "0" })
    }
}

"#,
            );

            code
        }

        fn instruction_name_to_variant(&self, name: &str) -> String {
            name.replace(".", "_").replace("-", "_").to_uppercase()
        }

        fn operand_to_typed_struct(&self, operand: &Operand, isa_base: &ISABase) -> String {
            let bit_length = operand.bit_lengths.get(isa_base).unwrap_or(&32);

            match operand.name.as_str() {
                name if name.starts_with("rs") || name.starts_with("rd") => {
                    format!("Register<{}>", bit_length)
                }
                "imm" => format!("Immediate<{}>", bit_length),
                "uimm" => format!("UImmediate<{}>", bit_length),
                "nzimm" => format!("NZImmediate<{}>", bit_length),
                "nzuimm" => format!("NZUImmediate<{}>", bit_length),
                "shamt" => format!("ShiftAmount<{}>", bit_length),
                "csr" => "CSRAddress".to_string(),
                "rm" => "RoundingMode".to_string(),
                "aq" | "rl" => "Bool".to_string(),
                "pred" | "succ" | "fm" => "FenceMode".to_string(),
                _ => "u32".to_string(),
            }
        }
    }
}

pub mod types {
    use serde::{Deserialize, Serialize};
    use std::{collections::HashMap, fmt::Display};
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
    pub enum ISAExtension {
        I,
        M,
        A,
        F,
        D,
        Q,
        C,
        Zifencei,
        Zicsr,
    }
    impl Display for ISAExtension {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ISAExtension::I => write!(f, "I"),
                ISAExtension::M => write!(f, "M"),
                ISAExtension::A => write!(f, "A"),
                ISAExtension::F => write!(f, "F"),
                ISAExtension::D => write!(f, "D"),
                ISAExtension::Q => write!(f, "Q"),
                ISAExtension::C => write!(f, "C"),
                ISAExtension::Zifencei => write!(f, "Zifencei"),
                ISAExtension::Zicsr => write!(f, "Zicsr"),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
    pub enum ISABase {
        RV32,
        RV64,
    }
    impl Display for ISABase {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ISABase::RV32 => write!(f, "RV32"),
                ISABase::RV64 => write!(f, "RV64"),
            }
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
    pub struct ISAModule {
        pub base: ISABase,
        pub extension: ISAExtension,
    }
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct Operand {
        pub name: String,
        pub bit_lengths: HashMap<ISABase, u8>,
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Instruction {
        pub name: String,
        pub extension: ISAExtension,
        pub isa_bases: Vec<ISABase>,
        pub operands: Vec<Operand>,
        pub assembly_syntax: String,
    }
}
